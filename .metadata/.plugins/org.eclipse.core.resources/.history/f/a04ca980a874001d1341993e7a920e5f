/*
 * scheduler.c
 *
 *  Created on: Nov 11, 2022
 *      Author: ADMIN
 */

#include "scheduler.h"

sTasks SCH_tasks_G[SCH_MAX_TASKS];
uint8_t current_index_task = 0;
#define TICK 10


void SCH_Init(void){
	current_index_task = 0;
}

void SCH_Add_Task ( void (*pFunction)() , uint32_t DELAY, uint32_t PERIOD){
	if(current_index_task < SCH_MAX_TASKS){

		SCH_tasks_G[current_index_task].pTask = pFunction;
		SCH_tasks_G[current_index_task].Delay = DELAY/TICK;
		SCH_tasks_G[current_index_task].Period =  PERIOD/TICK;
		SCH_tasks_G[current_index_task].RunMe = 0;

		SCH_tasks_G[current_index_task].TaskID = current_index_task;//for delete

		current_index_task++;
	}
}

unsigned char SCH_Delete_Task (uint32_t taskID) {
	if (taskID < 0 || SCH_tasks_G[taskID].pTask == 0 ) return 0;
	SCH_tasks_G[taskID].pTask = 0x0000 ;
	SCH_tasks_G[taskID].Delay = 0;
	SCH_tasks_G[taskID].Period = 0;
	SCH_tasks_G[taskID].RunMe = 0;
	return 1;

}

void SCH_Update(void){
	for(int Index = 0;Index< current_index_task;Index++){
//		if(SCH_tasks_G[i].Delay > 0){
//			SCH_tasks_G[i].Delay--;
//		}
//		else{
//			if (SCH_tasks_G[Index].Period)  SCH_tasks_G[i].Delay = SCH_tasks_G[i].Period;
//			SCH_tasks_G[i].RunMe +=1;
//		}
        // Check if there is a task at this location
		if (SCH_tasks_G[Index].pTask){
			if (SCH_tasks_G[Index].Delay == 0) {
				// The task is due to run
				// Inc. the 'RunMe' flag
				SCH_tasks_G[Index].RunMe += 1;
				if (SCH_tasks_G[Index].Period) {
					// Schedule periodic tasks to run again
					SCH_tasks_G[Index].Delay = SCH_tasks_G[Index].Period;
				}
			} else {
				// Not yet ready to run: just decrement the delay
				SCH_tasks_G[Index].Delay -= 1;
			}
		}
	}
}

void SCH_Dispatch_Tasks(void){
	for(int i = 0; i < current_index_task; i++){
		if(SCH_tasks_G[i].RunMe > 0){
			SCH_tasks_G[i].RunMe--;
			(*SCH_tasks_G[i].pTask)();
		}
		if( SCH_tasks_G[i].Period == 0){
			SCH_Delete_Task(i);
		}
	}

}


/////////////////////////////////////////////////////////////
//void SCH_Init(void) {
//    unsigned char i;
//    for (i = 0; i < SCH_MAX_TASKS; i++) {
//        SCH_Delete_Task(i);
//    }
//}
//
//void SCH_Update(void){
//    unsigned char Index;
//    // NOTE: calculations are in *TICKS* (not milliseconds)
//    for (Index = 0; Index < SCH_MAX_TASKS; Index++) {
//        // Check if there is a task at this location
//        if (SCH_tasks_G[Index].pTask){
//            if (SCH_tasks_G[Index].Delay == 0) {
//                // The task is due to run
//                // Inc. the 'RunMe' flag
//                SCH_tasks_G[Index].RunMe += 1;
//                if (SCH_tasks_G[Index].Period) {
//                    // Schedule periodic tasks to run again
//                    SCH_tasks_G[Index].Delay = SCH_tasks_G[Index].Period;
//                }
//            } else {
//                // Not yet ready to run: just decrement the delay
//                SCH_tasks_G[Index].Delay -= 1;
//            }
//        }
//    }
//}
//
//unsigned char SCH_Add_Task(void (* pFunction)(), unsigned int DELAY, unsigned int PERIOD)
//{
//    unsigned char Index = 0;
//    // First find a gap in the array (if there is one)
//    while ((SCH_tasks_G[Index].pTask != 0) && (Index < SCH_MAX_TASKS))
//    {
//       Index++;
//    }
//    // If we're here, there is a space in the task array
//    SCH_tasks_G[Index].pTask = pFunction;
//    SCH_tasks_G[Index].Delay = DELAY/TICK;
//    SCH_tasks_G[Index].Period = PERIOD/TICK;
//    SCH_tasks_G[Index].RunMe = 0;
//    // return position of task (to allow later deletion)
//    return Index;
//}
//
//void SCH_Dispatch_Tasks(void)
//{
//    unsigned char Index;
//    // Dispatches (runs) the next task (if one is ready)
//    for (Index = 0; Index < SCH_MAX_TASKS; Index++){
//        if (SCH_tasks_G[Index].RunMe > 0) {
//            (*SCH_tasks_G[Index].pTask)(); // Run the task
//            SCH_tasks_G[Index].RunMe -= 1; // Reset / reduce RunMe flag
//            // Periodic tasks will automatically run again
//            // - if this is a 'one shot' task, remove it from the array
//            if (SCH_tasks_G[Index].Period == 0)
//            {
//                SCH_Delete_Task(Index);
//            }
//        }
//    }
//}
//
//unsigned char SCH_Delete_Task (uint32_t taskID) {
//	if (taskID < 0 || SCH_tasks_G[taskID].pTask == 0 ) return 0;
//	SCH_tasks_G[taskID].pTask = 0x0000 ;
//	SCH_tasks_G[taskID].Delay = 0;
//	SCH_tasks_G[taskID].Period = 0;
//	SCH_tasks_G[taskID].RunMe = 0;
//	return 1;
//
//}
//
//
